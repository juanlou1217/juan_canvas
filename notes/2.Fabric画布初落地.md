# Fabric画布初落地

> **提交**: `caea4f08` | **时间**: 2025-10-25 17:40:17 | **作者**: juanlou1217

【开发笔记】

一、本次交付清单  
1. 功能：基于 Fabric.js 的可视化画布首次集成到在线原型编辑器，支持图形拖拽、缩放、旋转、属性调整等基础设计能力。  
2. 技术栈：Next.js 15（App Router）+ TypeScript + Fabric.js 5.3（browser 版）+ TailwindCSS + shadcn/ui。  
3. 关键概念：  
   - Canvas 与 DOM 混合渲染：Fabric 负责图形层，React 负责 UI 层，两者通过 ref 解耦；  
   - 自适应画布：useAutoResize Hook 监听父容器尺寸，动态 setDimensions 保证 1:1 像素渲染；  
   - 项目级路由：/editor/[projectid] 作为独立编辑域，隔离多人协作场景。

二、为什么选 Fabric.js  
1. 成熟度：5.x 版本 API 稳定，社区插件丰富（网格、对齐、自由绘制、SVG 导出等），后续 AI 抠图、自动布局可直接复用生态。  
2. 浏览器版：fabric@5.3.0-browser 剔除了 Node 依赖，避免在 Next.js 边缘运行时出现 jsdom/canvas 二进制冲突；同时保留对象序列化能力，方便后续把 JSON 存到 DB。  
3. 性能：对象模型 + 脏矩形渲染，比直接操作 Canvas 2D API 省去大量手动重绘逻辑；Fabric 的 viewportTransform 也让“缩放/平移”无需重计算坐标。  
4. 扩展性：Fabric 的“子类即对象”模式，可快速封装 AI 生成图、组件库图标、代码组件等自定义类，与设计系统保持一致。

三、架构与目录  
src/features/editor/  
├─ components/Editor.tsx          // 画布宿主，负责 Fabric 实例生命周期  
├─ hooks/useEditor.ts             // 封装 addRect、addText、toJSON、loadJSON 等命令式 API  
├─ hooks/useAutoResize.ts         // ResizeObserver + debounce，动态调整 canvas 像素尺寸  
└─ types/fabric.d.ts              // 模块声明，解决 fabric 无官方 ESM 类型问题  

四、核心实现细节  
1. 初始化与清理  
   - 在 useEffect 中 new fabric.Canvas(ref.current, { fireRightClick: true, stopContextMenu: false })，开启右键菜单自定义；  
   - 销毁时先 canvas.dispose()，再移除窗口监听，防止热更新内存泄漏。  
2. 自适应画布  
   - 父容器由 Tailwind 的 flex-1 撑满，useAutoResize 里用 ResizeObserver 取 contentRect，再 canvas.setDimensions({ width, height }, { backstoreOnly: false }) 同步 CSS 像素与 Canvas 像素；  
   - 窗口 dpr 变化时，setZoom(1 / devicePixelRatio) 保持 1:1，避免图片模糊。  
3. 与 React 数据流解耦  
   - useEditor 返回的命令函数（addXxx、updateXxx）内部直接操作 fabric 实例，不经过 React state，减少重渲染；  
   - 需要 UI 回显属性时（如选中矩形颜色），通过 canvas.on('selection:created') 把选中对象写入 Zustand store，再驱动右侧属性面板。  
4. 服务端渲染安全  
   - 在 /editor/[projectid] 页面加 dynamic(() => import('features/editor/components/Editor'), { ssr: false })，避免 Node 环境找不到 HTMLCanvasElement。  
5. 类型补丁  
   - fabric 5.3 没有官方 ESM 类型，手动在 global.d.ts 中 declare module 'fabric'，并 Pick 出常用接口，保证编译通过。

五、踩坑与解决  
1. npm i fabric 默认装的是带 node-canvas 的完整版，本地 dev 正常，Vercel 边缘函数会报“cannot find canvas binary”；解决：锁定 fabric@5.3.0-browser 并删除 node_modules 重装。  
2. Fabric 对象序列化默认会丢失自定义字段（如 aiPrompt、componentId），需要在 toObject 时加额外参数：  
   toObject(['aiPrompt', 'componentId'])，并在 loadFromJSON 的 reviver 里还原。  
3. 热更新导致出现“duplicate canvas”——useRef 保存实例，useEffect 清理里 dispose + 置空，确保 StrictMode 下只创建一次。  
4. Tailwind 的 dark 模式会把 canvas 背景也变黑，导致空白错觉；在 Editor.tsx 里手动给 canvas.wrapperEl 加 bg-white，隔离主题变量。

六、可复用片段  
自适应 Hook（简化版）：  
```ts
export const useAutoResize = (canvas: fabric.Canvas | null) => {
  useEffect(() => {
    if (!canvas) return;
    const ro = new ResizeObserver(([entry]) => {
      const { width, height } = entry.contentRect;
      canvas.setDimensions({ width, height }, { backstoreOnly: false });
      canvas.requestRenderAll();
    });
    ro.observe(canvas.wrapperEl!);
    return () => ro.disconnect();
  }, [canvas]);
};
```

七、下一步演进  
1. 持久化：把 canvas.toJSON(['aiPrompt']) 存到 Postgres（drizzle-orm 已引入），支持版本快照。  
2. 协作：基于 y-fabric 把 Fabric 对象转成 Y.Map，实现 WebSocket 实时同步。  
3. AI 接入：  
   - 选中区域调用 Replicate/stable-diffusion-inpainting，返回后 fabric.Image.fromURL 插入；  
   - 自动布局：把对象树送 GPT-4o，返回对齐/间距指令，再映射到 Fabric 的 set({ left, top })。  
4. 性能：对象 >500 个时，启用 fabric.Canvas#skipOffscreen 和 objectCaching 策略；导出阶段用 offscreenCanvas 在 Web Worker 里生成缩略图，不阻塞主线程。  

八、小结  
这一版把“能跑起来的画布”先搬到线上，为后续 AI+协作奠定基石。Fabric 的选型验证了“功能完备 + 浏览器零依赖”思路可行；通过 Hook 化封装，让 React 只负责 UI 状态，画布逻辑下沉到命令层，后续无论换 Konva 还是 Pixi 都可平滑迁移。

---

**变更文件**: package-lock.json, package.json, src/app/(auth)/layout.tsx, src/app/(auth)/login/page.tsx, src/app/(auth)/register/page.tsx, src/app/editor/[projectid]/page.tsx, src/app/globals.css, src/features/editor/components/editor.tsx, src/features/editor/hooks/use-editor.ts, src/features/editor/hooks/useAuteResize.ts